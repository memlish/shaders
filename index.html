<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<style>
		canvas {
			width: 100%;
			height: 100%
		}

		body {
			margin: 0;
		}
	</style>
</head>

<body>
	<canvas id="c"></canvas>
	<script src="js/three.js"></script>
	<script>
		'use strict';

		/* global THREE */

		async function main() {
			const canvas = document.querySelector('#c');
			const renderer = new THREE.WebGLRenderer({ canvas });
			renderer.autoClearColor = false;

			const camera = new THREE.OrthographicCamera(
				-1, // left
				1, // right
				1, // top
				-1, // bottom
				-1, // near,
				1, // far
			);
			const scene = new THREE.Scene();
			const plane = new THREE.PlaneBufferGeometry(2, 2);

			const texture = new THREE.TextureLoader().load("./ostap1.jpg");
			// texture.wrapS = THREE.RepeatWrapping;
			// texture.wrapT = THREE.RepeatWrapping;
			// texture.repeat.set(4, 4);

			const vertexShader = `
				uniform vec2 size;

				attribute vec2 aTextureCoord;
				varying highp vec2 vTextureCoord;

				void main() {
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					vTextureCoord = aTextureCoord;
				}
			`

			const fragmentShader = `
				#include <common>
				
				uniform vec3 iResolution;
				uniform float iTime;
				uniform sampler2D feature_map;

				varying highp vec2 vTextureCoord;

				void mainImage( out vec4 fragColor, in vec2 fragCoord )
				{
					vec2 uv = fragCoord.xy/iResolution.xy;
					// uv.x *= iResolution.x/iResolution.y;

					fragColor = texture2D(feature_map, uv);;
				}

				void main() {
					mainImage(gl_FragColor, gl_FragCoord.xy);
				}
			`;
			const uniforms = {
				iTime: { value: 0 },
				iResolution: { value: new THREE.Vector3() },
				feature_map: { value: texture },
			};
			const material = new THREE.ShaderMaterial({
				vertexShader,
				fragmentShader,
				uniforms,
			});
			scene.add(new THREE.Mesh(plane, material));

			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
					renderer.setSize(width, height, false);
				}
				return needResize;
			}

			function render(time) {
				time *= 0.001;  // convert to seconds

				resizeRendererToDisplaySize(renderer);

				const canvas = renderer.domElement;
				uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
				uniforms.iTime.value = time;

				renderer.render(scene, camera);

				requestAnimationFrame(render);
			}

			requestAnimationFrame(render);
		}

		main();
	</script>
</body>

</html>