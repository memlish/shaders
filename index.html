<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        canvas {
            width: 256px;
            height: 256px;
        }

        body {
            margin: 15%;
        }
    </style>
</head>

<body>
    <div>
        <canvas id="c"></canvas>
        <div style="position: fixed; top: 0px; left: 0px; cursor: pointer; opacity: 0.9; z-index: 10000;">
            <canvas width="80" height="48" style="width: 80px; height: 48px; display: block;"></canvas>
            <canvas width="80" height="48" style="width: 80px; height: 48px; display: none;"></canvas>
            <canvas width="80" height="48" style="width: 80px; height: 48px; display: none;"></canvas>
        </div>
    </div>

    <script src="js/three.js"></script>
    <script type="module">
        /* global THREE */
        import Stats from './jsm/libs/stats.module.js';
        let stats;

        const container = document.createElement('div');
        document.body.appendChild(container);
        stats = new Stats();
        container.appendChild(stats.dom);


        async function main() {
            const canvas = document.querySelector('#c');
            const renderer = new THREE.WebGLRenderer({ canvas });
            renderer.autoClearColor = false;
            console.log(renderer.capabilities.maxTextureSize)


            const camera = new THREE.OrthographicCamera(
                -1, // left
                1, // right
                1, // top
                -1, // bottom
                -1, // near,
                1, // far
            );
            const scene = new THREE.Scene();
            const plane = new THREE.PlaneBufferGeometry(2, 2);

            const vertexShader = await fetch('./shaders/vertexShader.glsl')
                .then(response => { return response.text(); });

            const fragmentShader = await fetch('./shaders/fragmentShader.glsl')
                .then(response => { return response.text(); });

            const texture_min_max = await fetch("./textures/texture_min_max.json")
                .then(response => {
                    const j = response.json();
                    return j;
                });

            var texture_loader = new THREE.TextureLoader();
            const xy_texture = texture_loader.load("./textures/xy_texture.png");
            const xz_texture = texture_loader.load("./textures/xz_texture.png");
            const yz_texture = texture_loader.load("./textures/yz_texture.png");

            const uniforms = {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector3() },

                texture_min: { value: texture_min_max.min },
                texture_max: { value: texture_min_max.max },

                xy_texture: { value: xy_texture },
                xz_texture: { value: xz_texture },
                yz_texture: { value: yz_texture }
            };
            const material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms,
            });
            scene.add(new THREE.Mesh(plane, material));

            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                    renderer.setSize(width, height, false);
                }
                return needResize;
            }

            function render(time) {
                time *= 0.001;  // convert to seconds

                resizeRendererToDisplaySize(renderer);

                const canvas = renderer.domElement;
                uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
                uniforms.iTime.value = time;

                renderer.render(scene, camera);
                stats.update()

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }

        main();
    </script>
</body>

</html>