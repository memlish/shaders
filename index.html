<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<style>
		canvas {
			width: 100%;
			height: 100%
		}

		body {
			margin: 0;
		}
	</style>
</head>

<body>
	<canvas id="c"></canvas>
	<script src="js/three.js"></script>
	<script>
		'use strict';

		/* global THREE */

		async function main() {
			const canvas = document.querySelector('#c');
			const renderer = new THREE.WebGLRenderer({ canvas });
			renderer.autoClearColor = false;

			const camera = new THREE.OrthographicCamera(
				-1, // left
				1, // right
				1, // top
				-1, // bottom
				-1, // near,
				1, // far
			);
			const scene = new THREE.Scene();
			const plane = new THREE.PlaneBufferGeometry(2, 2);

			var feature_map_json = await fetch("./head_feature_map.json")
				.then(response => {
					const j = response.json();
					return j;
				});

			const texture = new THREE.DataArrayTexture(feature_map_json['data'], 256, 256, 57);
			texture.format = THREE.RedFormat;
			texture.needsUpdate = true;
			console.log(texture)


			const vertexShader = `
				out vec2 vUv;
				uniform vec2 size;

				void main() {
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

					vUv.xy = position.xy / size + 0.5;
					vUv.y = 1.0 - vUv.y; // original data is upside down
				}
			`

			const fragmentShader = `
				#include <common>
				
				precision highp float;
				precision highp int;
				precision highp sampler2DArray;

				uniform vec3 iResolution;
				uniform float iTime;
				uniform sampler2DArray feature_map;
				uniform int depth;
				in vec2 vUv;

				void mainImage( out vec4 fragColor, in vec2 fragCoord )
				{
					vec4 color = texture( feature_map, vec3( vUv, 55) );
					fragColor = vec4( color.rrr, 1.0 );
				}

				void main() {
					mainImage(gl_FragColor, gl_FragCoord.xy);
				}
			`;
			const uniforms = {
				iTime: { value: 0 },
				norm_min: { value: feature_map_json['min'] },
				norm_max: { value: feature_map_json['min'] },
				iResolution: { value: new THREE.Vector3() },
				feature_map: { value: texture },
				depth: { value: 1 },
				size: { value: new THREE.Vector2(50, 50) },
			};
			const material = new THREE.ShaderMaterial({
				vertexShader,
				fragmentShader,
				uniforms,
			});
			scene.add(new THREE.Mesh(plane, material));

			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
					renderer.setSize(width, height, false);
				}
				return needResize;
			}

			function render(time) {
				time *= 0.001;  // convert to seconds

				resizeRendererToDisplaySize(renderer);

				const canvas = renderer.domElement;
				uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
				uniforms.iTime.value = time;

				renderer.render(scene, camera);

				requestAnimationFrame(render);
			}

			requestAnimationFrame(render);
		}

		main();
	</script>
</body>

</html>