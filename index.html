<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<style>
		body {
			margin: 0;
		}
	</style>
</head>

<body>
	<canvas id="c" width="804" height="929"></canvas>
	<script src="js/three.js"></script>
	<script>
		'use strict';

		/* global THREE */

		function main() {
			const canvas = document.querySelector('#c');
			const renderer = new THREE.WebGLRenderer({ canvas });
			renderer.autoClearColor = false;

			const camera = new THREE.OrthographicCamera(
				-1, // left
				1, // right
				1, // top
				-1, // bottom
				-1, // near,
				1, // far
			);
			const scene = new THREE.Scene();
			const plane = new THREE.PlaneBufferGeometry(2, 2);

			const fragmentShader = `
				#include <common>

				uniform vec3 iResolution;
				uniform float iTime;
				varying vec2 vUv;

				void mainImage( out vec4 fragColor, in vec2 fragCoord )
				{
					vec2 uv = fragCoord/iResolution.xy;

					uv -= .5;
    				uv.x *= iResolution.x/iResolution.y;
					// Output to screen
					float d = length(uv);
					float r = .2;
					float c = smoothstep(r, r-0.03, d);
					float c2 = smoothstep(r/2.,r/2.-0.03, d);
					//if(d > r/2.) c2 = 1.; else c2 = 0.;
					vec3 col1 = vec3((c - 1.0) * -1.);
					
					vec3 col2 = vec3(c2,0.,0.);

					// Output to screen
					fragColor = vec4(col1+col2,1);
				}

				void main() {
					mainImage(gl_FragColor, vUv * iResolution.xy);
				}
			`;

			const vertexShader = `
				varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}
			`;

			const uniforms = {
				iTime: { value: 0 },
				iResolution: { value: new THREE.Vector3(1, 1, 1) },
			};
			const material = new THREE.ShaderMaterial({
				vertexShader,
				fragmentShader,
				uniforms,
			});
			scene.add(new THREE.Mesh(plane, material));

			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
					renderer.setSize(width, height, false);
				}
				return needResize;
			}

			function render(time) {
				time *= 0.001;  // convert to seconds

				resizeRendererToDisplaySize(renderer);

				const canvas = renderer.domElement;
				uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
				uniforms.iTime.value = time;

				renderer.render(scene, camera);

				requestAnimationFrame(render);
			}

			requestAnimationFrame(render);
		}

		main();
	</script>
</body>

</html>